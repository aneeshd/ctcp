#!/usr/bin/python
import sys, os
import math

import matplotlib
print "Using MPL version:", matplotlib.__version__

import pylab
from pylab import *


def graph(log_file, keyword='', local_node='', remote_node='', showGraph=True, save=True):
    '''Process the log files generated by srvctcp stored in the logs/ directory.'''
    times0      = []
    instant_BW0 = []
    average_BW0 = []
    blockno0    = []
    snd_cwnd0   = []
    ssthresh0   = []
    slr0        = []
    slr_long0   = []
    srtt0       = []
    rto0        = []
    rtt0        = []

    times1      = []
    instant_BW1 = []
    average_BW1 = []
    blockno1    = []
    snd_cwnd1   = []
    ssthresh1   = []
    slr1        = []
    slr_long1   = []
    srtt1       = []
    rto1        = []
    rtt1        = []

    current = 0.03
    mss     = 1398
    res     = 0.01
    abw     = 0
    bw      = 0

    xmt_times0 = []
    xmt_blockno0 = []
    xmt_times1 = []
    xmt_blockno1 = []
    xmt_current = 0.03

    print "Processing log at: " + log_file

    f = open(log_file, 'r')
    for line in f:
        values = line.split(" ")

        if values[-1] == "rcv0\n":
            # The variable values is a list of the form
            # [time, blockno, snd_cwnd, slr, slr_long, srtt, rto, rtt, rcv]

            # Compute instant and avg bw

            abw += mss
            bw  += mss

            time = float(values[0])

            if time > current and time <= (current + res):
                times0.append(time)

                instant_BW0.append(8e-6*bw/res)
                average_BW0.append(8e-6*1.0*abw/current)

                blockno0.append(values[1])
                snd_cwnd0.append(values[2])
                ssthresh0.append(values[3])
                slr0.append(values[4])
                slr_long0.append(values[5])
                srtt0.append(values[6])
                rto0.append(values[7])
                rtt0.append(values[8])


                current = res + current
                bw = 0
            elif time > (current + res):
                zero_point = res*math.floor(time/res)
                times0.append(current)
                times0.append(zero_point)

                instant_BW0.append(0)
                instant_BW0.append(0)

                average_BW0.append(8e-6*1.0*abw/current)
                average_BW0.append(8e-6*1.0*abw/zero_point)

                blockno0.append(values[1])
                blockno0.append(values[1])

		# need to appen twice to account for zero_point
                snd_cwnd0.append(values[2])
                snd_cwnd0.append(values[2])

                ssthresh0.append(values[3])
                ssthresh0.append(values[3])
                slr0.append(values[4])
                slr0.append(values[4])
                slr_long0.append(values[5])
                slr_long0.append(values[5])
                srtt0.append(values[6])
                srtt0.append(values[6])
                rto0.append(values[7])
                rto0.append(values[7])
                rtt0.append(values[8])
                rtt0.append(values[8])

		current = zero_point + res
		bw = 0

        elif values[-1] == "rcv1\n":
            # The variable values is a list of the form
            # [time, blockno, snd_cwnd, slr, slr_long, srtt, rto, rtt, rcv]

            # Compute instant and avg bw

            abw += mss
            bw  += mss

            time = float(values[0])

            if time > current and time <= (current + res):
                times1.append(time)

                instant_BW1.append(8e-6*bw/res)
                average_BW1.append(8e-6*1.0*abw/current)

                blockno1.append(values[1])
                snd_cwnd1.append(values[2])
                ssthresh1.append(values[3])
                slr1.append(values[4])
                slr_long1.append(values[5])
                srtt1.append(values[6])
                rto1.append(values[7])
                rtt1.append(values[8])


                current = res + current
                bw = 0
            elif time > (current + res):
                zero_point = res*math.floor(time/res)
                times1.append(current)
                times1.append(zero_point)

                instant_BW1.append(0)
                instant_BW1.append(0)

                average_BW1.append(8e-6*1.0*abw/current)
                average_BW1.append(8e-6*1.0*abw/zero_point)

                blockno1.append(values[1])
                blockno1.append(values[1])

		# need to appen twice to account for zero_point
                snd_cwnd1.append(values[2])
                snd_cwnd1.append(values[2])

                ssthresh1.append(values[3])
                ssthresh1.append(values[3])
                slr1.append(values[4])
                slr1.append(values[4])
                slr_long1.append(values[5])
                slr_long1.append(values[5])
                srtt1.append(values[6])
                srtt1.append(values[6])
                rto1.append(values[7])
                rto1.append(values[7])
                rtt1.append(values[8])
                rtt1.append(values[8])

		current = zero_point + res
		bw = 0

        elif values[-1] == "xmt0\n":

            time = float(values[0])

            if time > xmt_current:
                xmt_times0.append(time)
                xmt_blockno0.append(values[1])                
                xmt_current = xmt_current + res/10

        elif values[-1] == "xmt1\n":

            time = float(values[0])

            if time > xmt_current:
                xmt_times1.append(time)
                xmt_blockno1.append(values[1])                
                xmt_current = xmt_current + res/10

    # print average_BW
    subplot(511)
    plot(times0, instant_BW0, 'r-', times0, average_BW0, 'r--', times1, instant_BW1, 'g-', times1, average_BW1, 'g--')
    grid(True)
    title('CTCP Performance')
    ylabel('Mbs')

    # print congestion window
    subplot(512)
    plot(times0, snd_cwnd0, 'r-', times0, ssthresh0, 'r--', times1, snd_cwnd1, 'g-', times1, ssthresh1, 'g--')
    grid(True)
    ylabel('Congestion window (packets)')

    # print round trip time and rto
    subplot(513)
    plot(times0, rtt0, 'r-', times0, srtt0, 'r--', times0, rto0, 'b-', times1, rtt1, 'g-', times1, srtt1, 'g--', times1, rto1, 'b--')
    grid(True)
    ylabel('time (s)')

    # print round trip time and rto
    subplot(514)
    plot(xmt_times0, xmt_blockno0, 'ro', xmt_times1, xmt_blockno1, 'b*')
    grid(True)
    ylabel('blockno')
    ylim((0,2))

    # print loss rate
    subplot(515)
    plot(times0, slr0, 'r-', times0, slr_long0, 'r--', times1, slr1, 'b-', times1, slr_long1, 'b--')
    grid(True)
    xlabel('time (s)')
    ylabel('loss rate')

    F = pylab.gcf()

    fig_path = log_file.replace('logs', 'figs')
    fig_path = fig_path[0:-4] # Remove the .log at the end
    fig_path = fig_path + "_" + local_node + "->" + remote_node + "_" + keyword +".pdf"

    if save == True:
        if not os.path.isabs(fig_path):
            fig_dir = os.path.abspath(os.path.join(os.path.abspath(os.path.dirname(__file__)), '..', os.path.dirname(fig_path)))

            if not os.path.exists(fig_dir):
                os.makedirs(fig_dir)

        DefaultSize = F.get_size_inches()
        F.set_size_inches( (DefaultSize[0]*2, DefaultSize[1]*2) )

        F.savefig(fig_path, orientation='portrait', papertype='letter')

    if showGraph == True:
        show()


def main(args):
    graph(args[0], save=True)


if __name__ == '__main__':
    if len(sys.argv) < 2:
        sys.exit("Usage: ./scripts/grapher <srvctcp_output>")
    main(sys.argv[1:])


